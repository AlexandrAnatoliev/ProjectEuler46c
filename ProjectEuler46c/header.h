// header.h
// Пишем здесь структуры и объявления функций характерные для этой программы
// остальные #include пишем в местах, где они используются

#include <stdbool.h>	

enum bit_nums               // числа в виде битовых флагов
{
	one = 0x1,              // 00000001
	three = 0x1 << 1,		// 00000010
	five = 0x1 << 2,		// 00000100
	seven = 0x1 << 3,		// 00001000
	nine = 0x1 << 4			// 00010000
} bit_t;

enum check_sign				// параметр для функции check()
{
	more,					// больше
	less					// меньше
}sign_t;

typedef struct list			// структура для хранения массива чисел
{
	int len;                // длина массива
	char* arr;              // указатель на массив
}list_t;

// Передаем во все функции указатели на структуры вне зависимости от того, будет она изменяться или нет,
// чтобы пользователь функций не путался когда нужно, а когда не нужно ставить указатель.
// Неизменяемые параметры помечаем const

list_t list_сalloc(int len);
// операция:	создание структуры и выделение ей памяти
// предусловие:	len указывает на необходимую длину char - массива
// постусловие:	если память успешно выделена - поля структуры заполнены нулями {.len = 0, .arr[] = {0}}
//				если память выделить не удалось, то {.len = 0, .*arr = NULL}

bool push_num(list_t* prime_hash, int num);
// операция:	внесение числа int в хеш-массив структуры prime_hash
// предусловие:	prime_hash указывает на ранее инициализированную структуру
//				num - на вносимое в массив простое число
// постусловие:	если число успешно внесено в массив структуры, то возвращается true, иначе - false

bool is_prime(const list_t* prime_hash, int num);
// операция:	определения простого числа (проверка его наличия в хеш-массиве простых чисел)
// предусловие:	prime_hash	- указывает на структуру с хеш-массивом ранее внесенных простых чисел
//				num			- проверяемое простое число
// постусловие:	если число простое (есть в массиве структуры), то возвращается true, иначе - false

int get_next_prime(const list_t *prime_hash, int num);
// операция:	получение следующего простого числа после num
// предусловие:	prime_hash	- указывает на структуру с хеш-массивом ранеем несенных простых чисел
//				num			- текущее простое число
// постусловие:	возвращает найденное следующее простое число или 0 - в случае выхода за пределы массива

bool is_goldbach(const list_t *prime_hash, int two_sqrt_arr[], int num);
// операция:	проверка удовлетворения числом условия Гольдбаха 
// предусловие:	prime_hash		- указывает на структуру с хеш-массивом ранее внесенных простых чисел
//				two_sqrt_arr	- массив двойных квадратов натуральных чисел
//				num				- проверяемое составное и нечетное число
// постусловие:	возвращает true, если число удовлетворяет условию Гольдбаха, иначе - false

